<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
    "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<!-- mapper 태그 내부에 sql문을 넣으면 mybatis가 알아서 해준다.. -->
<mapper namespace="com.soninlawisdice.mapper.SecondhandMapper">
	<!-- namespace를 만든 인터페이스와 맞춰주기 -->
	<!-- id를 service의 함수명과 맞춰주기 -->
	<!-- resultType을 지정해주면 해당 클래스 타입으로 결과값이 저장된다. -->
	

	<!-- list -->
	<select id="selectTradeList" resultType="java.util.HashMap" >
	
		SELECT 
			*
		FROM (
				SELECT 
					T.*, M.M_NICK, M.M_ID, S.S_CONTENT, ROW_NUMBER() OVER(ORDER BY T_NO DESC) AS RNUM 
				FROM
					TRADE T
				LEFT JOIN
					MEMBER M
				ON 
					T.M_NO = M.M_NO
				LEFT JOIN
					SUBJECT S
				ON 
					T.S_NO = S.S_NO					
				WHERE 
					1=1 
					<include refid="subjectSearch"></include>
					<include refid="tradeSearch"></include>
			) 
		WHERE 
			RNUM BETWEEN #{scri.rowStart} AND #{scri.rowEnd}
		ORDER BY
			T_NO DESC
				
	</select> <!-- 1=1 조건 달아야, 처음에 검색어 없이 호출시에도, WHERE 하나만 남아서 BadGrammarException이 뜨지 않는다.. -->
	
	
	<!-- list count -->	
	<select id="tradeListCount" resultType="int">

		SELECT 
			COUNT(T.T_NO)
		FROM 
			TRADE T
		LEFT JOIN
			MEMBER M
		ON 
			T.M_NO = M.M_NO
		LEFT JOIN
			SUBJECT S
		ON 
			T.S_NO = S.S_NO	
		WHERE 
			1=1 
			<include refid="subjectSearch"></include>	
			<include refid="tradeSearch"></include>
			AND T_NO > 0

	</select>
	
	
	<!-- 글 보기(content_view) -->
	<select id="selectContentOne" resultType="java.util.HashMap" parameterType="int">
	
		SELECT 
			T.*, M.M_NICK, M.M_ID, S.S_CONTENT
		FROM
			TRADE T
		LEFT JOIN
			MEMBER M
		ON 
			T.M_NO = M.M_NO
		LEFT JOIN
			SUBJECT S
		ON 
			T.S_NO = S.S_NO
		WHERE
			T_NO = #{t_no}
			
	</select> 
	
	
	<!-- 글 보기(content_view): 게임, 가격 가져오기 -->
	<select id="selectTrade_gameList" resultType="com.soninlawisdice.vo.Trade_gameVO" parameterType="int">
	
		SELECT 
			*
		FROM
			TRADE_GAME TG
		WHERE
			T_NO = #{t_no}
		ORDER BY 
			TG_NO ASC
			
	</select> 
	
	
	<!-- 글 삭제 -->
	<delete id="deleteContent">
	
		DELETE 
		FROM 
			TRADE 
		WHERE 
			T_NO = #{t_no}
			
	</delete>
	
	
	<!-- 조회수 -->
	<update id="upHitContent">
	
		UPDATE
			TRADE 
		SET 
			T_HIT = T_HIT + 1 
		WHERE
			T_NO = #{t_no}
			
	</update>
	
	
	<!-- 글쓰기 : 다중 INSERT -->
	<!-- Map을 사용할때 index는 key객체가 되고 항목은 value객체 -->
	
	<!-- get_trade_seq 함수 생성하여 현재 trade_seq 리턴 -->
	<!-- oracle db에 생성한 함수는 다음과 같다. -->
	<!-- 		 
		CREATE FUNCTION get_trade_seq RETURN NUMBER IS
		BEGIN
		  RETURN TRADE_GAME_SEQ.nextval;
		END;
		/
	 -->
	<insert id="insertTrade" >
	
		INSERT ALL
		INTO
			TRADE 
			(T_NO, M_NO, S_NO, T_TITLE, T_CONTENT) 
		VALUES 
			(trade_seq.nextval, #{m_no}, #{tradeVO.s_no},  #{tradeVO.t_title}, #{tradeVO.t_content}) 	
		
		<foreach collection="gamePrice" index="game" item="price">		
			INTO
				TRADE_GAME 
				(TG_NO, T_NO, G_NO, TG_NAME, TG_PRICE ) 
			VALUES 
				(get_trade_seq, trade_seq.nextval, null, #{game}, #{price} )
		</foreach>
			
		SELECT  
			*
		FROM 
			DUAL			
		
	</insert>	

	
	<!-- 글 작성시 10 포인트 적립 -->
	<update id = "boardPointUpdate">
		UPDATE 
			MEMBER 
		SET 
			M_POINT = M_POINT + 10 
		WHERE 
			M_NO = #{m_no} 
	</update>
	
	
	<!-- 글 수정: TRADE -->
	<update id="modify" >
	
		UPDATE 
			TRADE
		SET 
			S_NO = #{tradeVO.s_no},
			T_TITLE = #{tradeVO.t_title},
			T_CONTENT = #{tradeVO.t_content},
			T_UPDATED_DATE = SYSDATE
			
			<if	test="tradeVO.t_island == 1">
				, T_ISLAND = 2
			</if>
		WHERE T_NO = #{tradeVO.t_no}
		
		
			
	</update>
	
	
	<!-- 글 수정: TRADE_GAME -->
	<update id="modifyTG" >
		
		
<!-- 		UPDATE 
			TRADE_GAME
			
			SET 
				TG_NAME = #{game},
				TG_PRICE = #{price}
			WHERE 
				T_NO = #{t_no} AND 
				
				TG_NO = #{tg_no} -->	
	
{
declare

     -- 각 컬럼에서 사용할 테이블의 선언 (이 테이블은 sql의 테이블이 아니라 1차원 배열임)
    TYPE tg_no_arr IS TABLE OF NUMBER(15,0)
    INDEX BY BINARY_INTEGER;
    
    TYPE game_arr IS TABLE OF VARCHAR2(40 BYTE)
    INDEX BY BINARY_INTEGER;
    
    TYPE price_arr IS TABLE OF NUMBER(10,0)
    INDEX BY BINARY_INTEGER;

     -- 테이블타입으로 변수를 선언해서 사용: 형식 [변수이름 테이블타입]
    tg_no tg_no_arr;
    game game_arr;
    price price_arr;
    
     -- for 문 위한 변수 선언
    i BINARY_INTEGER := 0;

   BEGIN

    -- mybatis foeach로 대입 일일이 돌리기
    <foreach collection="gamePrice" index="game" item="price">	
        game := #{game};
        price := #{price};
    </foreach>    
      
     

    -- 수정한 개수만큼만 update
    update trade_game tg set tg.tg_name = game(i), tg.tg_price = price(i) where tg.tg_no = tg_no(i);

    END LOOP;
   

    -- 해당 글의 tg_no만 arr에 넣기
     FOR tg_nolist IN (select tg_no from trade_game where t_no = 396 )  loop
            
            i := i + 1;

           -- 테이블 변수에 검색된 결과를 넣는다
            tg_no(i) := tg_nolist.tg_no ; 

      END LOOP;
      
      -- 아나... 수정시 입력한 게임이름 개수가 기존것보다 많으면(초과) tg_no추가해서 새로 insert.
      -- 같으면 그대로 update,
      -- 적으면 게임 개수만큼만 update 후에 남는거 delete

      -- 1부터 i까지 FOR 문을 실행 
      FOR cnt IN 1..i LOOP

    -- 수정한 개수만큼만 update
    update trade_game tg set tg.tg_name = game(i), tg.tg_price = price(i) where tg.tg_no = tg_no(i);

      END LOOP;

  END 
  }
  
	</update>
	
	
	<!-- 검색조건 sql -->
	<sql id="tradeSearch">
		<if test="scri.searchType != null">
			<if test="scri.searchType == 't'.toString()">AND T_TITLE LIKE '%' || #{scri.keyword} || '%'</if>
			<if test="scri.searchType == 'c'.toString()">AND T_CONTENT LIKE '%' || #{scri.keyword} || '%'</if>
			<if test="scri.searchType == 'w'.toString()">AND M_NICK LIKE '%' || #{scri.keyword} || '%'</if>
			<if test="scri.searchType == 'tc'.toString()">
					AND (T_TITLE LIKE '%' || #{scri.keyword} || '%') or (T_CONTENT LIKE '%' || #{scri.keyword} || '%')</if>
		</if>
	</sql>
	
	<sql id="subjectSearch">
		<if test="s_content != null">
			<if test="s_content == 's'.toString()">AND S_CONTENT LIKE '판매중'</if>
			<if test="s_content == 'b'.toString()">AND S_CONTENT LIKE '구매중'</if>
			<if test="s_content == 'c'.toString()">AND S_CONTENT LIKE '거래완료'</if>
		</if>
	</sql>

</mapper>